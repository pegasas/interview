# c++面向对象

面向对象的三大特性：（1）封装（2）继承（3）多态

# 继承
继承体系中的构造、拷贝、析构顺序？（派生类只负责自己成员的拷贝控制，可以(换而言之非必须，如果不显示调用，会调用父类合成的默认版本)在初始值列表或函数体中调用基类相应函数）
继承中的名字查找（作用域嵌套、从子类到父类查找；成员名字的处理）
成员函数体内、成员函数的参数列表的名字解析时机（因此，务必将“内嵌的类型声明”放在class起始处）
同名名字隐藏（如何解决？(域作用符，从指示的类开始查找)、不同作用域无法重载、using的作用？除此之外呢？）
虚继承（解决什么问题？(多继承中的子对象冗余)）

## 多态
多态的实现

## public，private、protected

# c++基础
## struct
struct、class区别
## 构造函数
4种构造函数(1)默认构造函数(2)委托构造函数(3)拷贝构造函数(4)移动构造函数
合成的默认拷贝构造函数（默认行为？什么情况下不会合成？怎么解决？如果成员包含类内初始值，合成默认构造函数会使用该成员的类内初始值初始化该成员）
拷贝构造函数（调用时机、合成版的行为、explicit？、为何第一个参数必须是引用类型）
移动拷贝构造函数（非拷贝而是窃取资源、与noexcept?、何时合成）
可否通过对象或对象的引用(指针或引用)调用
类构造函数初始值列表（顺序、效率、无默认构造函数的成员,const成员,引用成员必须通过初始值列表初始化）
删除的合成函数（一般函数而言不想调用的话不定义就好）
# 赋值运算符
拷贝赋值运算符（合成版的行为？、与delete？、自定义时要注意自赋值，参数与返回类型、大部分组合了拷贝构造函数与析构函数的工作）
阻止拷贝（某些对象应该独一无二(比方说人)、C++11前:private并且不定义(试图拷贝会报链接错误)，C++11:=delete 《Effective C++:条款6》）
移动赋值运算符（与noexcept？何时合成）
可以定义为成员或非成员函数，定义成成员函数时第一个操作数隐式绑定到this指针
不可重载的操作符有哪些？（?:，::）
## 析构函数
销毁过程的理解（delete会执行哪些操作？逆序析构成员）
为什么析构函数中不能抛出异常？（不能是指“不应该”，C++本身并不禁止《Effective C++:条款8》）
如果析构函数中包含可能抛出异常的代码怎么办？（Effective C++:条款8》）
可否通过对象或对象的引用(指针或引用)调用
为什么将继承体系中基类的析构函数声明为虚函数？（《Effective C++:条款7》）
不应该将非继承体系中的类的虚函数声明为虚函数（《Effective C++:条款7》）
不应该继承析构函数非虚的类（《Effective C++:条款7》，final防止继承）
防止继承的方式
## 虚函数
虚函数的实现原理？对类大小的影响？（vtbl是一个由函数指针组成的数组，无论pb指向哪种类型的对象，只要能够确定被调函数在虚函数中的偏移值，待运行时，能够确定具体类型，并能找到相应vptr，进一步能找出真正应该调用的函数）
为什么不要在构造、析构函数中调用虚函数？（子对象的base class构造期间，对象的类型是base class 《Effective C++:条款9》，设置虚函数指针的时机）
虚函数被覆盖？
virtual函数动态绑定，缺省参数值静态绑定（《Effective C++:条款37》）
纯虚函数与抽象基类（纯虚函数与虚函数、一般成员函数的选择）
内联函数、构造函数、静态成员函数可以是虚函数吗
## 其他
静态类型与动态类型（引用是否可实现动态绑定）
浅拷贝与深拷贝（安全性、行为像值的类与行为像指针的类）
如何定义类内常量？（enum而不是static const 《Effective C++:条款2》）
继承与组合(复合)之间如何选择？（《Effective C++:条款38》）
private继承？（《Effective C++:条款39》）
如何定义一个只能在堆上（栈上）生成对象的类？


# 内存管理
C++内存分区
new和malloc的区别？（函数，运算符、类型安全、计算空间、步骤，operator new的实现）
new[]与delete[]？（步骤：如何分配内存，构建对象、如何析构与释放内存？构造与析构）
new带括号和不带的区别？（无自定义构造函数时，不带括号的new只分配内存，带括号的new会初始化为0）
new时内存不足？（《Effective C++:条款49》）(new-handler)
malloc、calloc、realloc、alloca，malloc的实现
调用malloc函数之后，OS会马上分配内存空间吗？（不会，只会返回一个虚拟地址，待用户要使用内存时，OS会发出一个缺页中断，此时，内存管理模块才会为程序分配真正内存）
delete（步骤、delete与析构、可以delete空指针、可以delete动态const对象）
什么是内存泄露？如何检测与避免？（Mtrace，valgrind）
实现memcpy
memcpy与memmove的区别（前者不处理重叠，后者处理重叠）
能否使用memcpy比较两个结构体对象？
实现strlen、strcmp、strcat、strcpy
## 内存对齐
为什么要内存对齐？(性能原因、平台原因)
struct内存对齐方式？
如何取消内存对齐（添加预处理指令#pragma pack(1)）
## 智能指针
种类、区别、原理、能否管理动态数组
shared_ptr（使用、计数的变化，get()函数要注意什么）
unique_ptr(如何转移控制权)
weak_ptr(特点、用途：可以解决shared_ptr的循环引用问题)
手写实现智能指针



# 对象内存模型
数据成员
成员变量在类对象中的布局规则
通过指针和通过'.'进行Data Member存取的区别
数据成员的布局——无继承
数据成员的布局——不含多态的继承（C++标准并未强制指定派生类和基类成员的排列顺序；理论上编译器可以自由安排。在大部分编译器上，基类成员总是先出现，虚基类除外）
数据成员的布局——含多态的继承（vptr的位置也没有强制规定，放在不同位置分别有什么好处？）
数据成员的布局——多重继承（基类子对象的排列顺序也没有硬性规定；指针的调整方式？）
数据成员的布局——虚继承（虚基类子对象的偏移信息记录在虚函数表之前与使用一个额外指针来记录的对比？）
指向数据成员的指针
函数成员
nonstatic成员函数的转换（目的是为了提供和一般非成员函数相同的效率）
重载成员函数的名字处理
static成员函数的转换
编译器如何处理经由指针和经由‘.’进行的调用
指向函数成员的指针
虚函数的调用——单继承
虚函数的调用——多重继承（子类对象关联有多少个虚函数表？不同虚函数表的名称？执行期什么情况下如何调整this指针？）

# c++关键字
extern？（extern "C"?、与static？、有什么问题？、extern的时候定义变量？）
const？（修饰变量、修饰指针与引用、修饰成员函数 《Effective C++:条款3》）
mutable
define与const、enum、inline？（《Effective C++:条款2》、C中默认const是外部连接的，而C++中默认const是内部连接的）
explict?（抑制隐式转换、可通过显示转换或直接初始化解决、类外定义时不应重复出现）
noexcept？（承诺不会抛出异常）
default、delete?（显示要求编译器合成、不能被调用）
using？（用于命名空间？、用于类中？）
final？（修饰类？、修饰成员函数？只有虚函数能使用final）
auto(初始值为引用时类型为所引对象的类型、必须初始化、不能用于函数及模板)、decltype？
volatile?（对象的值可能在程序的控制外被改变时，应将变量申明为volatile，告诉编译器不应对这样的对象进行优化，如果优化，从内存读取后CPU会优先访问数据在寄存器中的结果，但是内存中的数据可能在程序之外被改变、可以既是const又是volatile，const只是告诉程序不能试图去修改它.volatile是告诉编译器不要优化，因为变量可能在程序外部被改变）
static局部变量
static全局变量未初始化（详细描述了进程的虚拟地址空间结构）
const关键字描述
inline和宏定义，static关键字
c++的virtual关键字
static 类的静态成员（所属？静态成员函数不能声明成const、类类型的成员、定义时不能重复使用static、具有类内初始值的静态成员定义时不可再设初值）


# 其它
调试程序的方法?（gdb）
遇到coredump要怎么调试？
模板的用法与适用场景
函数调用的压栈过程
sizeof和strlen的区别？（运算符与函数、计算的对象、编译时运行时）
union？
覆盖、重载与隐藏（覆盖要求参数完全相同，用于继承体系的虚函数中，重载要求参数不同）
C++是不是类型安全的？（不是，两个不同类型指针可以强制转换）
gcc和g++的区别？（gcc代表GUN Compiler Collection，是一堆编译器的集合，包括g++）
运行时类型识别实现对象比较函数
使用C++实现线程安全的单例模式
什么是异常安全？
两个文件中声明两个同名变量？（使用了与未使用extern？）
全局数组和局部数组的初始化？
指针和引用的区别？（代表意义、内存占用、初始化、指向是否可改、能否为空）
C/C++中的强制转换
如何修改const变量、const与volatile
静态类型获取与动态类型获取（typeid、dynamic_cast:转换目标类型必须是引用类型）
如何比较浮点数大小？（直接使用==比较出现错误的例子）
函数重载（参数必须不同(const修饰形参)、重载与作用域、继承中的重载(using)、重载与const成员函数）
解释一维指针，二维指针，一维数组，指针数组，函数指针相关的概念
char *a[]={"aa","bb","cc"}，求sizeof(a)的值（4因为多了一个 * 因此就是指针的大小）
C++生成库文件后做什么
基类的析构函数不是虚函数会怎么样
堆和栈的内存
堆内存的申请和释放
new/delete和malloc/free区别
虚函数和纯虚函数
poll epoll select
基类A，派生类B继承于A，A *a = new B[10]是否正确？会发生什么错误？a[5]能正确的取到对象吗？
vector赋值n个数，它需要拷贝几次
指针变量的大小
struct A{char a, int b};struct B{int b, char a}，把结构体A强制类型转换为B，会发生什么（字节对齐）
为什么会有字节对齐（地址总线访存）
c++如何比较两个对象
一个类如何被称为抽象类
抽象类可以实例化吗？为什么？
纯虚函数如何定义
如何让一个类被有限次数的实例化？
虚函数如何实现
static的作用
inline用法
C++中的多态，运行时多态的虚函数是如何实现的
class A
{
int a;
short b;
int c;
}
sizeof(A)的大小？类中加上double d;呢？
C++中override是什么 如何实现
c++ class struct区别
c++ inline介绍
malloc的实现方式
（只会分配进程虚拟地址空间，在使用时才会发生缺页中断，完成到物理地址的映射。其中Linux2.4内核版本在分配虚拟地址后，会直接发生缺页中断，但2.6版本后已经不这样做了，因为效率太低）
c++ 一个类的两个对象是否共享一张虚表？
c++ 带有虚函数、虚继承、菱形继承的类的内存布局如何？
c++ 实现一个类的容器，容器大小恒定，可以请求内存和释放内存。
c++ 四种cast和三种智能指针背一背。
c++ malloc函数通常如何实现？
c++ 在构造函数和析构函数中调用虚函数会怎么样？为什么析构函数也会那样？析构和构造的顺序是怎么样的？
c++ delete[]和delete有什么区别？delete[]是怎么知道size的？
c++ constexpr、volatile、explicit、mutable几个关键字分别是干什么用的？
C++的RTTI如何实现？类型信息保存在哪里？
c++ _cdecl、_stdcall、_fastcall等等调用规则分别是什么？有何区别？
c++ switch和多重if else的区别在哪里？switch对小范围case和大范围case有什么处理上的不同？
c++ 右值引用
c++ lambda是什么？捕获列表里有什么用？捕获方式有哪些？
c++ 模板的特化和偏特化分别是什么？如何基于模板实现简单的递归？
c++ STL各种容器底层用什么实现？CURD的复杂度是多少？

# c++设计模式
C++实现单例模式

# c++面向对象
C++虚函数，虚基类

# c++11
auto,decltype、explicit、lambda、final

C++11特性
（1）关键字:auto关键字, nullptr关键字
（2）stl容器:array,forwardlist,unordered_map,unordered_set
（3）多线程:thread, atomic, condition_variable
（4）智能指针:shared_ptr,weak_ptr,unique_ptr
（5）lambda表达式

左值引用，右值引用，std::move()
(1)左值引用：相当于把一个变量的地址付给另一个变量，这两个变量可以访问同一个内存
用法：Type & 左值引用名 = 左值表达式；
注意点：声明时必须初始化，初始化之后无法在改变；对别名的一切操作都等价于对原来变量的操作。
(2)右值引用：右值仅仅是一个数，而非内存中的某块地址
用法：Type && 右值引用名 = 右值表达式；
(3)std::move():可以直接把左值或者右值转换成右值引用
用法：Type && 右值引用名 = std::move(左值引用名);
注意：在调用完std::move之后，不能再使用左值引用，只能使用右值引用

默认构造函数，拷贝构造函数，赋值构造函数，移动构造函数
A();//默认构造函数
A(const A& a);//拷贝构造函数
oprator=(const A& a);//赋值构造函数
A(A&& a);//移动构造函数
可以在移动构造函数中实现 把a的数据直接转移到 新的变量b下面，而省去申请声明一个变量b， 把copy a->b， 然后释放a的空间。

C++智能指针shared_ptr,weak_ptr,unique_ptr



# stl
vector的底层
vector如何实现动态分配空间
vector将其中一个元素删除地址空间是怎么样的
map、set区别
STL迭代器如何实现
STL中vector底层
STL emplace_back
1）顺序容器与关联容器的比较？有哪些顺序容器与关联容器？
2）vector底层的实现（迭代器类型为随机迭代器）？insert具体做了哪些事？resize()调用的是什么？
3）vector的push_back要注意什么（大量调用会伴随大量的拷贝构造与析构，内存分配与释放）
4）vector的resize()与reserve()（测试程序）
5）如何释放vector的空间？（swap）、容器的元素类型为指针？（会有内存泄露，指针是trivial_destructor；也可以使用智能指针来管理）
6）vector的clear与deque的clear（vector的erase和clear只会析构不会释放内存，deque的erase和clear不但会析构，还可能会释放缓冲区）
7）list的底层实现（迭代器类型为双向迭代器）
8）deque的底层实现（迭代器类型为随机迭代器）
9）vector与deque的区别？（deque能以常数时间在首尾插入元素；deque没有capacity的概念）
10）map、set的实现原理（红黑树、对于set来说key和value合一，value就是key，map的元素是一个pair，包括key和value、set不支持[]，map(不包括multimap)支持[]）
11）set(map)和multiset(multimap)的区别？（set不允许key重复,其insert操作调用rb_tree的insert_unique函数，multiset允许key重复,其insert操作调用rb_tree的insert_equal函数）
12）set(multiset)和map(multimap)的迭代器（由于set(multiset)key和value合一，迭代器不允许修改key、map(multimap)除了key有data，迭代器允许修改data不允许修改key）
13）map与unordered_map的区别？（hash_map需要hash函数及等于函数，map只需小于函数）
14）set(multiset)和map(multimap)的迭代器++操作、--操作的时间复杂度？
15）空间分配器allocator
将new和delete的2阶段操作分离（construct和destroy负责内存分配？allocate和deallocate负责对象构造析构？）
SGI符合部分标准的空间分配器——std::allocator
SGI特殊的空间分配器——std::alloc（对象构造与析构、内存分配与释放——两级分配器）
第一级分配器（如何仿真new-handler机制？不能直接用C++ new-handler，因为没有使用::operator new）
第二级分配器（为什么要二级分配器？内存池与16个free-list？空间分配和释放的步骤？）
16）traits与迭代器相应类型

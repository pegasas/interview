# 左值，右值

左值是可以放在赋值号左边可以被赋值的值；左值必须要在内存中有实体；
右值当在赋值号右边取出值赋给其他变量的值；右值可以在内存也可以在CPU寄存器。
一个对象被用作右值时，使用的是它的内容(值)，被当作左值时，使用的是它的地址。

# 引用

引用
引用是C++语法做的优化，本质是靠指针来实现的。引用相当于变量的别名。

引用可以改变指针的指向，还可以改变指针所指向的值。
引用的基本规则：

声明引用的时候必须初始化，且一旦绑定，不可把引用绑定到其他对象；即引用必须初始化，不能对引用重定义；
对引用的一切操作，就相当于对原对象的操作。

## 左值引用和右值引用

左值引用
左值引用的基本语法：type &引用名 = 左值表达式；

右值引用
右值引用的基本语法type &&引用名 = 右值表达式；

右值引用的“&&”中间不可以有空格。

int a = 5;
int &add_a(a);//左值引用
int &&add_b(b + 1);//右值引用

纯右值：非引用返回的临时变量( int func(void) )、运算表达式产生的临时变量(b+c)、原始字面量(2)、lambda表达式等。
将亡值：将要被移动的对象、T&&函数返回值、std::move返回值和转换为T&&的类型的转换函数的返回值。
将亡值可以理解为通过“盗取”其他变量内存空间的方式获取到的值。在确保其他变量不再被使用、或即将被销毁时，通过“盗取”的方式可以避免内存空间的释放和分配，能够延长变量值的生命期。

## 引用折叠规则
经过类型推导的 T&& 类型，相比右值引用(&&)会发生类型变化，这种变化被称为引用折叠或崩塌。规则：

所有的右值引用叠加到右值引用上仍然还是一个右值引用；
所有的其他引用类型之间的叠加都将变成左值引用。
总之是，所有的右值引用叠加到右值引用上仍然是一个右值引用，其他引用折叠都是左值引用。

T& &、T& &&和T&& & 都折叠成类型 T&
T&& &&折叠成 T&&

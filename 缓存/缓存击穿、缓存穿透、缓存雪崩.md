# 缓存击穿、缓存穿透、缓存雪崩

缓存击穿

定义： 缓存中的key一般设有过期时间，如果某个key过期了，恰在这个时候，有大量的并发请求访问这个key，则这些请求都会到达DB,导致DB瞬间压力过大，压垮DB。

解决方案： 1.设置互斥锁，mutex。当缓存失效时不时立即去访问数据库，而是使用缓存工具的操作成功带返回值的操作，比如redis的setnx（set if not exit），memcache的add，利用setnx实现锁的效果。

缺点：可能造成死锁，或线程池阻塞

2.提前使用互斥锁
redist的超时时间是timeout1，value的超时时间是timeout2,timeout2 < timeout1。 当timeout2超时时，延长timeout2的时间。并重新设置到redis中。

3.永远不过期
不设置过期时间。
把过期时间设到value里，如果快要过期了，通过一个后台异步线程进行缓存的构建，也就是逻辑过期。

缓存穿透
  定义： 指有人用数据库中不存在的某个key访问，数据库中没有该key值，自然缓存中也不会有，该请求会直接到数据库。如果对该key的并发访问量过大，则会压垮数据库。

  解决方案：
1. 采用过滤器，把所有数据库中不可能存在的数据hash到一张大的bitmap中，如果key在数据库中不存在，将会被bitmap拦截。
2. 对查出为空的key，也在缓存中简历key value对，只是过期时间设的短一点，比如5minetes。

缓存雪崩
  定义： 指缓存中大量的数据在同一时间失效，这时有大量的请求会被直接转到数据库，造成数据库的压力过大。

  解决方案：1. 加锁，加队列，如mq，保证缓存的单线程写，避免key失效时，大量并发到达数据库。
2.把缓存失效时间错开。比如在原有失效时间上加一个随机值，比如1-5分钟，这样失效时间的重复率降低，降低集体失效的概率。

总结
  缓存雪崩是大量key同时失效事件，而缓存击穿和缓存穿透都是都是单个key失效，大量请求访问该key；不同的是缓存击穿，key对应的value值存在于数据库中，而缓存穿透的key, value不存在数据库中，可能被用来恶意攻击。

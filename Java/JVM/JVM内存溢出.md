# JVM内存溢出

1、java堆溢出

java对用于存储对象的实例，只要不断的创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么在对象数量达到最大堆的容量限制之后机会产生内存溢出异常。

当出现java堆内存溢出时，异常堆栈信息“java.lang.OutOfMemoryError”会跟着进一步提示“Java heap space”。

要解决这个区域的异常 ，一般会先通过内存映像分析工具对Dump出来的对转存储快照尽心分析，重点是确认内存中的对象是否是必要的，也就是先分清楚到底是内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）。

若果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄漏对象是通过怎样的路径与GC Roots相关并导致垃圾回收器无法自动回收他们。如果不存在泄漏，就是内存中的对象确实都还必须活着，那就应当检查虚拟机的堆参数（-Xmx和Xms）,与机器物理内存对比是否还可以调大，从代码上检查是否存在某些对象生命周期过长，持有状态时间过长的情况，尝试减少程序运行期的内存消耗。

2、虚拟机栈和本地方法栈溢出

如果线程请求的栈深度大于虚拟机所允许的最大深度，将会抛出StackOverflowError。如果虚拟机在扩展栈时无法申请到足够的内存空间则抛出OutOfMemoryError。

以上两种异常情况其实是对同一件事情的两种描述：当栈空间无法继续分配时，到底是栈内存太小，还是已经使用的栈空间太大。

试验表明：在单个线程下，无论是由于栈帧太大还是虚拟机栈容量太小，当内存无法分配的时候，虚拟机抛出的StackOverflowError异常。如果不限于单线程，通过不断的建立线程的方式到可以产生内存溢出异常，但是这样产生的内存溢出异常与栈空间是否足够大并不存在任何联系，或者更准确的说，在这种情况下，为每一个线程的栈分配的内存越大，反而越容易产生内存溢出异常。

如果是通过建立过多线程的方式到导致的内存溢出，在不能减少线程或者更换64位虚拟机的情况下，就只能通过减少最大堆和减少栈帧容量来换取跟多的线程。

原因很简单：操作系统分配给每一个进程的内存是有限制的，比如每个对进程的限制为2GB，虚拟机提供了参数来控制java堆和方法区的这两部分内存的最大值。则剩余的内存为：2GB（操作系统限制的大小）-Xmx（最大堆容量）-MaxPermSize（最大方法区容量）。程序计数器消耗的内存很小基本可以忽略。如果虚拟机进程本身消耗的内存不计算在内，那么剩下的内存就由虚拟机的虚拟机栈和本地方法栈“瓜分”了。每个线程分配到的内存容量越大，可以建立的线程数量自然就越少，建立线程时就越容易将剩下的内存耗尽。

3、方法区和运行时常量池溢出

若是运行时常量池溢出，在OutOfMemoryError后面跟随的提示信息是“PermGen space”，说明运行时常量池属于方法区（永久代）的一部分。

方法区用于存放Class的相关信息，如类名，访问修饰符，常量池，字段描述，方法描述。若运行时产生大量的类去填满方法区，直达溢出。比如Spring 对类进行增强时（创建代理类），都会使用到cglib这类字节码技术，增强的类越多，就需要越大的方法区来保证动态生成的Class可以加载到内存。再比如大量JSP或动态产生JSP文件应用（JSP第一次运行时需要编译为java类）等。

4、本机直接内存溢出

DirectMenory容量可通过-XX：MaxDirectMemorySize指定，如果不指定，则默认与java堆的容量最大值一样。

在使用NIO方式使用Native函数库直接分配堆外内存，存储在Java堆中的DirectByteBuffer对象在进行分配内存是时候会抛出内存溢出异常。但是它抛出异常时并没有真正向操作系统申请分配内存，而是通过计算得知内存无法分配，于是手动抛出异常。

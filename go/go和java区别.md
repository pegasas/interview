# go反射

1.反射原理：
Go的变量都是静态类型（声明时指定的类型），它也有底层类型（定义类型时指定的基础类型，即：它是以什么形式存储的）；
一个接口变量存储了一对（value, type）：赋值给这个接口变量的具体值value、以及这个值的类型描述符type；
Go的接口变量都是静态类型化的：一个接口类型变量总是保持同一个静态类型（即声明时指定的接口类型），即使在运行时它保存的值的类型发生变化，这些值总是满足这个接口。
接口的静态类型决定了能用接口变量调用哪些方法（接口中定义的方法，它们是保存的值的方法集的子集）；
反射是一种检查存储在接口变量中的（value, type）对的机制，反射操作所需的全部信息都源自接口变量（通过把变量转换为空接口变量，从而获得了该变量的value、type，这样就可以进行一系列的“反射操作”）；
reflect包中的两个类型：Type和Value，这两种类型提供了访问一个接口变量中所包含的（value, type）对的途径；

2.通过反射可以修改原对象：
原理：
因为给Go的函数、方法传递的都是形参的副本，同样的，反射一个对象时，形参被保存为一个接口对象并作为参数传递（复制），该接口变量是non-settable的，返回的Value也是non-settable的，对它调用Set方法会出现错误；
Value的CanSet方法用于测试一个Value的Settablity性质，它有点像unaddressability，但是更加严格，描述的是一个反射对象能够修改创造它的那个实际存储的值的能力。settability由反射对象是否保存原始项而决定。
所以，如果想通过反射来修改对象，必须先把该对象的指针传给reflect.ValueOf(&x)，这样得到的Value对象内部就保存了原对象指针的副本，只有找到该指针指向的值才能修改原始对象，通过Elem()方法就可以获得一个保存了原对象的Value对象，此时的Value对象就是settable的；
对于一个settable的Value反射对象，如 d := reflect.ValueOf(&x).Elem()：
d.CanAddr()方法：判断它是否可被取地址
d.CanSet()方法：判断它是否可被取地址并可被修改
通过一个settable的Value反射对象来访问、修改其对应的变量的方式：
方式1：通过把反射对象转换回原对象类型的指针，然后直接修改该指针
px := d.Addr().Interface().(*int)
第一步是调用Addr()方法，它返回一个Value，里面保存了指向变量的指针。
然后是在Value上调用Interface()方法，也就是返回一个interface{}，里面通用包含指向变量的指针。
最后，如果我们知道变量的类型，我们可以使用类型的断言机制将得到的interface{}类型的接口强制环为普通的类型指针。这样我们就可以通过这个普通指针来更新变量了
方式2：可直接通过Set()方法来修改
d.Set(reflect.ValueOf(4))
SetInt、SetUint、SetString和SetFloat等方法：d.SetInt(3)，注意：虽然如SetInt()等方法只要参数变量的底层数据类型是有符号整数就可以工作，但不能是一个引用interface{}类型的reflect.Value
小结：Value反射对象为了修改它们所表示的东西必须要有这些东西的地址

# 高可用
负载均衡+反向代理
隔离术
限流
降级
超时+重试
回滚
压测+预案

# 高并发
应用级缓存
HTTP缓存
多级缓存
连接池线程池
异步并发
扩容
消息队列

# 负载均衡
外网：DNS 全局负载均衡（GSLB）
内网：
DNS nginx中间引入LVS(软件负载均衡器)/F5(硬负载均衡器)

nginx:
2层负载均衡：改写报文mac地址为上游服务器mac地址
4层负载均衡：根据端口将报文转发到上游服务器（不同ip+端口）
7层负载均衡：根据端口和应用层协议主机名、URL将报文转发到上游服务器（不同ip+端口）

LVS DR工作模式
LVS和上游服务器共享一个VIP，通过改写目标报文mac地址为上游服务器mac地址，上游服务器直接响应报文到客户端，不经过LVS，直接提升性能。LVS和上游服务器必须在一个子网，为了解决跨子网问题而不影响性能，可以选择在LVS之后挂HAProxy集群解决跨网和性能问题。（nginx stream也可以）

负载均衡4个问题：
1. 配置上游服务器
2. 负载均衡算法：配置上游服务器负载均衡机制
3. 超时重试：上游服务器超时或不存活是否重试其他上游服务器
4. （上游）服务器心跳检查

# 反向代理

反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。

# 隔离术

## 线程隔离
把请求分类，交给不同线程池，一种业务线程池出问题不影响别的线程池

## 进程隔离
将系统拆分为多个系统，使得一个服务出问题时不影响其他服务

## 集群隔离
为服务提供单独的服务集群，为服务分组，当某一个分组出现问题时，不会影响到其他分组

## 机房隔离
多机房部署，每个机房服务有自己的服务分组，本机房服务只调用本机房服务，不进行跨机房调用。一个机房服务发生问题，通过DNS/负载均衡全部切到另一个机房，或自动重试其他机房服务。

## 读写隔离
通过主从模式将读和写集群分离，读服务只读从集群获取数据，主集群出现问题时，从集群还是可用的，不影响用户访问。从集群出现问题可以从其他集群重试。

## 动静隔离
动态内容与静态资源隔离，一般应该将静态资源放在CDN上

## 爬虫隔离
可以通过限流，或者将爬虫路由到单独集群，从而保证正常流量可用，爬虫流量尽量可用

## 热点隔离
将热点如秒杀抢购做成独立系统或服务单独隔离，从而保证热点出现问题不影响主流程
读热点：多级缓存
写热点：缓存+消息队列削峰

## 资源隔离
磁盘，CPU，网络等资源时常存在竞争问题
容器挂载到不同磁盘
绑定CPU到特定进程
中断绑定CPU或者优化中断均匀分发
大数据计算集群，数据库集群和应用集群隔离到不同机架和机房
环境隔离（测试环境、预发布环境/灰度环境、正式环境）
压测隔离（真实数据、压测数据）
AB测试（不同用户不同服务）
缓存隔离（大字节值单独）
查询隔离（复杂查询单独）

## Hystrix分布式服务故障

## Servlet3请求隔离（请求异步化）

# 限流
限制总并发数（数据库连接池、线程池）
限制瞬间并发数（nginx限制瞬间并发连接数）
限制时间窗口内的平均速率（Guava、nginx）
限制远程接口调用速率
限制MQ消费速率
根据网络连接数、网络流量、CPU或内存负载等来限流

## 限流算法
### 令牌桶算法

假如用户配置的平均发送速率为r，则每隔1/r秒一个令牌被加入到桶中；
假设桶最多可以存发b个令牌。如果令牌到达时令牌桶已经满了，那么这个令牌会被丢弃；
当一个n个字节的数据包到达时，就从令牌桶中删除n个令牌，并且数据包被发送到网络；
如果令牌桶中少于n个令牌，那么不会删除令牌，并且认为这个数据包在流量限制之外；
算法允许最长b个字节的突发，但从长期运行结果看，数据包的速率被限制成常量r。对于在流量限制外的数据包可以以不同的方式处理：
它们可以被丢弃；
它们可以排放在队列中以便当令牌桶中累积了足够多的令牌时再传输；
它们可以继续发送，但需要做特殊标记，网络过载的时候将这些特殊标记的包丢弃。

### 漏桶算法

漏桶可以看作是一个带有常量服务时间的单服务器队列，如果漏桶（包缓存）溢出，那么数据包会被丢弃。

## 应用级限流

### 限制总并发/连接/请求数
设置TPS/QPS阕值，超过则不响应或响应非常慢

### 限流总资源数
池化技术，连接池，线程池

### 限制某个接口的总并发/请求数
### 限制某个接口的时间窗（一段时间）请求数
### 平滑限流某个接口的请求数（令牌桶 漏桶）

## 分布式限流
Redis+Lua:
Nginx+Lua:
时间窗内某个接口的请求数限流,总并发/请求数,限制总资源数
Lua实现复杂令牌桶或漏桶算法

## 接入层限流
接入层：请求流量的入口
主要目的：负载均衡，非法请求过滤，请求聚合，缓存，降级，AB测试，服务质量监控等
Nginx:
ngx_http_limit_conn_module 对某个key对应的总的网络连接数进行限流，可按照IP限制IP的总连接数
ngx_http_limit_req_module 漏桶算法请求限流，有（1）平滑模式（2）允许突发模式

## 节流
限制多个相同事件间的最小执行时间间隔
(1)throttleFirst/throttleLast:在一个时间窗口内，如果有重复多个事件处理，只处理第一个/最后一个
(2)throttleWithTimeout:限制2个连续事件的先后执行事件不能小于某个事件窗口

# 降级特技

## 降级预案
日志级别降级预案：
（1）一般：偶尔因为网络抖动或正在上线超时，可以自动降级
（2）警告：服务在一段时间成功率有波动，可以自动或人工降级，并发送报警
（3）错误：可用率低于90%，数据库连接池用完了，访问量猛然增加到最大阕值，可以自动或人工降级
（4）严重错误：特殊原因数据出现错误，可以人工降级

是否自动化：（1）自动降级（2）人工降级
功能：（1）读服务降级（2）写服务降级
系统层次：多级降级
根据用户访问的服务链路：
（1）页面降级：某些页面占用了稀缺服务资源
（2）页面片段降级：某些页面部分数据错误
（3）页面异步请求降级：响应慢或者服务故障
（4）服务功能降级：不太重要的服务在异常情况下直接不获取
（5）读降级：多级缓存模式，
（6）写降级：
